# File-based logs (from shared volume)
<source>
  @type tail
  # Paths to your log files
  path /fluentd/log/app-quarkus.log,/fluentd/log/quarkus.log
  pos_file /tmp/quarkus.log.pos
  tag quarkus.logs
  <parse>
    @type regexp
    # Regex to parse your log format
    expression /^(?<time>\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2},\d{3})\s+(?<container>\S+)\s+(?<java_path>\S+)\s+(?<level>[A-Z]+)\s+\[(?<logger>[^\]]+)\]\s+\((?<thread>[^\)]+)\)\s+(?<message>.*)$/
    time_format %Y-%m-%d %H:%M:%S,%L
  </parse>
</source>

# --- TEST SECTION (keep for now) ---
<source>
  @type http
  port 9880
  bind 0.0.0.0
  tag quarkus.logs
  <parse>
    @type json
  </parse>
</source>
# --- END TEST SECTION ---

# Filter 1: Add a 'job' field to the record
<filter quarkus.**>
  @type record_transformer
  <record>
    job "quarkus-file"
  </record>
</filter>

# --- MODIFIED SECTION ---
# Filter 2: Re-format the record for the Loki plugin.
# We will build the *exact* record structure this
# old plugin seems to require.
<filter quarkus.**>
  @type record_transformer

  # We want to create a new record, not add to the old one.
  renew_record true
  # This enables the <record> directive to use
  # Ruby expressions to access old fields.
  enable_ruby true

  <record>
    # 1. Create the 'log' field
    log ${record["message"]}

    # 2. Create the nested 'labels' field
    # The plugin is crashing because it's looking for this
    # field and it's 'nil'.
    labels {
      "job": "${record['job']}",
      "level": "${record['level']}",
      "container": "${record['container']}",
      "logger": "${record['logger']}",
      "thread": "${record['thread']}"
    }
  </record>
</filter>
# --- END MODIFIED SECTION ---


# Route file-based Quarkus logs to Loki
<match quarkus.**>
  @type loki
  endpoint_url http://loki:3100
  tenant "quarkus"

  <buffer>
    @type memory
    flush_interval 10s
  </buffer>
</match>

# Catch-all for debugging (good to keep)
<match **>
  @type stdout
</match>
